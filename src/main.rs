use geozero::ToGeo;
use geo::{Geometry, Point};
use regex::Regex;
use gdal::{Dataset, vector::{OwnedFeatureIterator, Feature as GdalFeature, FieldValue}};
use ouroboros::self_referencing;
use std::{marker::PhantomData, error::Error, fs::File};
use flatgeobuf::{FgbReader, FallibleStreamingIterator, reader_state::FeaturesSelectedSeek, FeatureProperties};

trait Driver {
	fn can_open(path: &str) -> bool where Self: Sized;
	fn open(path: &str) -> Result<Self, Box<dyn Error>> where Self: Sized;

	// forward the reader 1 record
	fn forward(&mut self) -> Result<bool, Box<dyn Error>>; // Ok(false) -> end loop
	// accessors sort of like in Serde
	fn get_field_i64(&self, field_name: &str) -> Result<Option<i64>, Box<dyn Error>>;
	fn get_field_point(&self, field_name: &str) -> Result<Option<Point>, Box<dyn Error>>;
}

impl Driver for Box<dyn Driver> {
	fn can_open(path: &str) -> bool where Self: Sized { panic!() }
	fn open(path: &str) -> Result<Self, Box<dyn Error>> where Self: Sized { panic!() }
	fn forward(&mut self) -> Result<bool, Box<dyn Error>> { self.forward() }
	fn get_field_i64(&self, field_name: &str) -> Result<Option<i64>, Box<dyn Error>> { self.as_ref().get_field_i64(field_name) }
	fn get_field_point(&self, field_name: &str) -> Result<Option<Point>, Box<dyn Error>> { self.as_ref().get_field_point(field_name) }
}

#[self_referencing]
pub struct FgbDriver {
	fp: File,
	#[borrows(mut fp)]
	#[covariant]
	features_selected: FgbReader<'this, File, FeaturesSelectedSeek>,
}

impl Driver for FgbDriver {
	fn can_open(path: &str) -> bool {
		path.ends_with(".fgb")
	}

	fn open(path: &str) -> Result<Self, Box<dyn Error>> {
		let fp = File::open(path)?;
		Ok(FgbDriverTryBuilder {
			fp,
			features_selected_builder: |fp| FgbReader::open(fp)?.select_all(),
		}.try_build()?)
	}

	fn forward(&mut self) -> Result<bool, Box<dyn Error>> {
		// getters should use self.features_selected.get() to get current feature
		Ok(self.with_features_selected_mut(|b| { if let Ok(c) = b.next() { return c.is_some() } else { false }} ))
	}
	fn get_field_i64(&self, field_name: &str) -> Result<Option<i64>, Box<dyn Error>> {
		let ft = self.borrow_features_selected().cur_feature();
		Ok(Some(ft.property::<i64>(field_name)?))
	}
	fn get_field_point(&self, _field_name: &str) -> Result<Option<Point>, Box<dyn Error>> {
		let ft = self.borrow_features_selected().cur_feature();
		match ft.to_geo()? {
			Geometry::Point(p) => Ok(Some(p)),
			_ => panic!("wrong geometry type!")
		}
	}
}

#[self_referencing]
pub struct GpkgDriver {
	pub feature_iterator: OwnedFeatureIterator,
	#[borrows(mut feature_iterator)]
	#[covariant]
	current_feature: Option<GdalFeature<'this>>,
}

impl<'a> Driver for GpkgDriver {
	fn can_open(path: &str) -> bool {
		let re = Regex::new(r"^(?P<file_path>(?:.*/)?(?P<file_name>(?:.*/)?(?P<file_own_name>.*)\.(?P<extension>gpkg)))(?::(?P<layer_name>[a-z0-9_-]+))?$").unwrap();
		re.is_match(&path)
	}

	fn open(path: &str) -> Result<Self, Box<dyn Error>> {
		let dataset = Dataset::open(path)?;
		// TODO: choose layer from path expression or return error if can't choose
		let layer = dataset.into_layer(0)?;
		let feature_iterator = layer.owned_features();
		GpkgDriverTryBuilder { feature_iterator, current_feature_builder: |fi| Ok(None) }.try_build()
	}

	fn forward(&mut self) -> Result<bool, Box<dyn Error>> {
		if let Some(f) = self.with_feature_iterator().next() {
			self.borrow_current_feature().replace(f);
			Ok(true)
		}
		else { Ok(false) }
	}
	fn get_field_i64(&self, field_name: &str) -> Result<Option<i64>, Box<dyn Error>> {
		/*match match match &self.feature {
			Some(f) => f.field(field_name)?,
			None => panic!("no feature but reading field")
		} {
			Some(v) => v,
			None => return Ok(None),
		} {
			FieldValue::IntegerValue(v) => Ok(Some(v.into())),
			FieldValue::Integer64Value(v) => Ok(Some(v.try_into()?)),
			_ => panic!("wrong format")
		}*/
		Ok(Some(123))
	}

	fn get_field_point(&self, _field_name: &str) -> Result<Option<Point>, Box<dyn Error>> {
		/*match match &self.feature {
			Some(f) => Some(f.geometry().to_geo()?),
			None => panic!("no feature read yet"),
			_ => None::<Geometry> // TODO: this is just to fix the non-exhaustive patterns
		} {
			Some(Geometry::Point(g)) => Ok(Some(g)),
			// just to fix the return types/exhaustiveness
			None => Ok(None),
			_ => panic!("what have I just got?")
		}*/
		Ok(Some(Point::from((12.3, 45.6))))
	}
}

#[derive(Debug)]
struct MyStruct {
	x: i64,
	geometry: Point
}

// auto-generated by macro
struct MyStructIter(Box<dyn Driver>);

// auto-generated by macro
impl<'a> MyStruct {
	fn iter_from(driver: Box<dyn Driver>) -> MyStructIter {
		MyStructIter(driver)
	}
}

impl MyStructIter {
	fn next_(&mut self) -> Result<Option<MyStruct>, Box<dyn Error>> {
		if !self.0.forward()? { return Ok(None) }

		Ok(Some(MyStruct {
			x: self.0.get_field_i64("x")?.unwrap(),
			geometry: self.0.get_field_point("geometry")?.unwrap()
		}))
	}
}

impl Iterator for MyStructIter {
	type Item = Result<MyStruct, Box<dyn Error>>;
	fn next(&mut self) -> Option<Self::Item> {
		self.next_().transpose()
	}
}



fn main() -> Result<(), Box<dyn Error>> {
	let t = Box::new(FgbDriver::open("local.fgb")?) as Box<dyn Driver>;

	for item in MyStruct::iter_from(t) {
		let item = item?;

	}
	Ok(())
}
